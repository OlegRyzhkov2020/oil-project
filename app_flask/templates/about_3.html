<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Data Journey</title>

  <script src ="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="http://d3js.org/topojson.v0.min.js"></script>

  <link rel="stylesheet" href="static/css/sim_style.css" type="text/css" media="screen"/>

</head>
<body>
  {% extends "menu.html" %}
  {% block content %}
  <div class="container-fluid padding first-container">
    <!-- <div class="row">
        <div class="col-md-12 text-center">
            <h5>Oil Data Analytics - A Machine Learning Journey</h5>
        </div>
    </div>        -->
    <div class="row">
        <div class="col-md-12 text-center">
            <!-- We also populate the timeline into this div at the top of the screen -->
            <div id="year"></div>
        </div>
    </div>
    <!-- This is where the good stuff goes -->
    <div class="row">
        <!-- Placeholder for the evolving chart -->
        <div id="chart" class="col-md-8"></div>
        <!-- Placeholder for the evolving image and note / description -->
        <div class="col-md-4">
           <div id="image"></div>
           <p id="note" style="text-align:center"></p>
        </div>
    </div>
    <!--
    <div class="row" style="text-align:center">
        <div id="speed">
        <div class="togglebutton slow" data-val="slow">Slow</div>
        <div class="togglebutton medium" data-val="medium">Med</div>
        <div class="togglebutton fast current" data-val="fast">Fast</div>
    </div>
    -->
    <div class="row">
        <cite>
            <a href="https://towardsdatascience.com/animated-storytelling-using-the-javascript-d3-library-a1c2264142ad">Source code adopted from Keith Mcnulty on Medium.com</a>
        </cite>
    </div>
    </div>
    </div>
</div>

 <!-- D3 JavaScript -->
 <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
 <!-- Custom Javascript for the data story -->
<script>
    var USER_SPEED = "slow";

    var width = 750,
        height = 500,
        padding = 1,
        maxRadius = 3;
        // color = d3.scale.category10();

    var sched_objs = [],
        curr_minute = 0;

    var act_codes = [
        {"index": "0", "short": "Accurate", "desc": "Accurate"},
        {"index": "1", "short": "Inaccurate", "desc": "Inaccurate"},
    ];


    var speeds = { "slow": 200, "medium": 125, "fast": 75 };

    // Over the course of this animation we slowly iterate through this array of objects, and use the data to display text and images on the page.
    var time_notes = [
        { "start_minute": 1, "stop_minute": 51, "model": "ARIMA", "img": "static/images/david.jpg", "color": "yellow", "note": "David made this visualization by adopting code he found from the Information Super Highway", "chart": "static/images/oil_logo.png", "modeldetails": "Autoreggressive Integrated Moving Average Model"},
        { "start_minute": 54, "stop_minute": 104, "model": "Recurrent Neural Network", "img": "static/images/oleg.jpg",  "color": "blue", "note": "Oleg is what we call a freeloader, he is part of the team but hasn't really done anything of value.", "chart": "static/images/timeSeries_1.png", "modeldetails": "Artificial Neural Network using connections between nodes to form a directed graph along a temporal sequence."},
        { "start_minute": 107, "stop_minute": 157, "model": "Linear", "img": "static/images/elaine.jpg",  "color": "red", "note": "Elaine understands things like 'Math' and 'Statistics', we are pretty sure she is a witch.", "chart": "static/images/timeSeries_2.png", "modeldetails": "The most well known and understood algorithm in Machine Learning!"},
        { "start_minute": 160, "stop_minute": 210, "model": "Logistical", "img": "static/images/zuzana.jpg",  "color": "blue", "note": "Zuzana really hopes this is a picture of her, and not some other zuzana that we found on linkedin. That would be awkward.", "chart": "static/images/timeSeries_3.png", "modeldetails": "Exploring the data as a binary dependent variable"},
        { "start_minute": 213, "stop_minute": 263, "model": "Final Model", "img": "static/images/jildiz.jpg",  "color": "red", "note": "Jildiz is our resident machine learning data scientist. Her aritificial intelligence model is going to take over the world.", "chart": "static/images/timeSeries_4.png", "modeldetails": "This model will create self-driving jetpacks. We're skipping cars"},
        ];

    // Over the course of this animation we iterate through this array of models and results to create the moving dots.
    var performance = [
        {"model": "ARIMA", "accuracy": 80, "inaccuracy": 20},
        {"model": "Recurrent", "accuracy": 87, "inaccuracy": 13},
        {"model": "Linear", "accuracy": 70, "inaccuracy": 30},
        {"model": "Logistical", "accuracy": 99, "inaccuracy": 1},
        {"model": "Final Model", "accuracy": 92, "inaccuracy": 8}
    ];

    var notes_index = 0;


    // Activity to put in center of circle arrangement
    var center_act = "Accurate",
        center_pt = { "x": 280, "y": 165 };


    // Coordinates for activities
    var foci = {};
    act_codes.forEach(function(code, i) {
        if (code.desc == center_act) {
            foci[code.index] = center_pt;
        } else {
            var theta = 2 * Math.PI / (act_codes.length-1);
            foci[code.index] = {x: 250 * Math.cos((i - 1) * theta)+380, y: 250 * Math.sin((i - 1) * theta)+365 };
        }
    });


    // Start the SVG
    var svg = d3.select("#chart").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr('position', 'absolute')
        .attr('left', '200px')
        .attr('top', '200px');


    // Load data and let's do it. This is a funky data structure, but it seems to operate like a csv.
    d3.csv("static/data/model_performance.csv", function(error, data) {

        // Trying to loop through this thing 10x to get a better picture.
        for (var j = 0; j < 10; j++) {
            for (var i = 0; i < 100; i++) {
                possibilities = [];

                performance.forEach(function(d) {

                    if (i < d.accuracy) {
                        possibilities.push({'act':0, 'duration':53});
                    }
                    else {
                        possibilities.push({'act':1, 'duration':53});
                    }
                })

                sched_objs.push(possibilities);
            };
        // This is the outer array, each element represents a 'probability'
        }

        console.log(sched_objs)

        // Used for percentages by minute
        var act_counts = {"0": 0, "1": 0};

        // A node for each person's schedule
        var nodes = sched_objs.map(function(o,i) {
            var act = o[0].act;
            //This line seems to be where we start getting the percentages.
            act_counts[act] += 1;
            var init_x = foci[act].x + Math.random();
            var init_y = foci[act].y + Math.random();
            return {
                act: act,
                radius: 3,
                x: init_x,
                y: init_y,
                color: color(act),
                moves: 0,
                next_move_time: o[0].duration,
                sched: o,
            }
        });

        var force = d3.layout.force()
            .nodes(nodes)
            .size([width, height])
            // .links([])
            .gravity(0)
            .charge(0)
            .friction(.9)
            .on("tick", tick)
            .start();

        var circle = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("r", function(d) { return d.radius; })
            .style("fill", function(d) { return d.color; });
            // .call(force.drag);

        // Activity labels
        var label = svg.selectAll("text")
            .data(act_codes)
            .enter().append("text")
            .attr("class", "actlabel")
            .attr("x", function(d, i) {
                if (d.desc == center_act) {
                    // messing with this using the - 120 so that we can read the description.
                    return center_pt.x - 120;
                } else {
                    var theta = 2 * Math.PI / (act_codes.length-1);
                    return 340 * Math.cos((i - 1) * theta)+380;
                }

            })
            .attr("y", function(d, i) {
                if (d.desc == center_act) {
                    return center_pt.y;
                } else {
                    var theta = 2 * Math.PI / (act_codes.length-1);
                    return 340 * Math.sin((i - 1) * theta)+365;
                }

            });

        label.append("tspan")
            .attr("x", function() { return d3.select(this.parentNode).attr("x"); })
            // .attr("dy", "1.3em")
            .attr("text-anchor", "middle")
            .text(function(d) {
                return d.short;
            });
        label.append("tspan")
            .attr("dy", "1.3em")
            .attr("x", function() { return d3.select(this.parentNode).attr("x"); })
            .attr("text-anchor", "middle")
            .attr("class", "actpct")
            .text(function(d) {
                // This is where the percentages come from, they are wrongly based on 10 instead of 100.
                return act_counts[d.index] + "%";
            });


        // Update nodes based on activity and duration
        function timer() {
            d3.range(nodes.length).map(function(i) {
                var curr_node = nodes[i],
                    curr_moves = curr_node.moves;

                // Time to go to next activity
                if (curr_node.next_move_time == curr_minute) {
                    if (curr_node.moves == curr_node.sched.length-1) {
                        curr_moves = 0;
                    } else {
                        curr_moves += 1;
                    }

                    // Subtract from current activity count
                    act_counts[curr_node.act] -= 1;

                    // Move on to next activity
                    curr_node.act = curr_node.sched[ curr_moves ].act;

                    // Add to new activity count. This also messes with the percentages.
                    act_counts[curr_node.act] += 1;

                    curr_node.moves = curr_moves;
                    curr_node.cx = foci[curr_node.act].x;
                    curr_node.cy = foci[curr_node.act].y;

                    nodes[i].next_move_time += nodes[i].sched[ curr_node.moves ].duration;
                }

            });

            force.resume();
            curr_minute += 1;

            // Update percentages
            label.selectAll("tspan.actpct")
                .text(function(d) {
                    return readablePercent(act_counts[d.index]);
                });

            // Update header and notes
            var true_minute = curr_minute % 1440;
            if (true_minute == time_notes[notes_index].start_minute) {
                d3.select("#year")
                    .style("color", "#fffced")
                    .style("text-align", "left")
                    .style("font-size", "300%")
                    .style("font-family", "adobe-caslon-pro")
                    .text(time_notes[notes_index].model)
                    .transition()
                    .duration(500)
                    .style("text-align", "center")
                    .style("color", "#000000");
            }

            if (true_minute == time_notes[notes_index].start_minute) {
                d3.select("#year").append('p')
                    .style("color", "#fffced")
                    .style("text-align", "left")
                    .style("font-size", "50%")
                    .style("font-family", "adobe-caslon-pro")
                    .text(time_notes[notes_index].modeldetails)
                    .transition()
                    .duration(500)
                    .style("text-align", "center")
                    .style("color", "#000000");
            }

            if (true_minute == time_notes[notes_index].start_minute + 10) {
                d3.select("#image").append('img')
                    .attr('src', time_notes[notes_index].img)
                    .attr('width', 200)
                    .attr('height', 250)
                    .style('position', 'absolute')
                    .style('top', '50px')
                    .style('left', '100px')
                    .style('opacity', 0)
                    .style("display", "block")
                    .style("background", time_notes[notes_index].color)
                    .style("padding", "8px")
                    .style("border", "1px solid #ccc")
                    .style("box-shadow", "5px 5px 5px #999")
                    .transition()
                    .duration(1000)
                    .style('opacity', 1);
            }

            if (true_minute == time_notes[notes_index].start_minute + 10) {
                d3.select("#note")
                    .style("top", "500px")
                    .style("color", "#fffced")
                    .style("font-size", "150%")
                    .style("font-style", "italic")
                    .transition()
                    .duration(500)
                    .style("top", "370px")
                    .style("color", "#000000")
                    .text(time_notes[notes_index].note);
            }

            if (true_minute == time_notes[notes_index].stop_minute - 5) {
                d3.select('#image')
                    .transition()
                    .duration(500)
                    .attr('opacity', 0);
            }

            // Make note disappear at the end.
            else if (true_minute == time_notes[notes_index].stop_minute) {

                d3.select("#note").transition()
                    .duration(500)
                    .style("top", "500px")
                    .style("color", "#fffced");

                d3.select("#year").transition()
                    .duration(500)
                    .style("top", "300px")
                    .style("color", "#fffced");

                notes_index += 1;
                if (notes_index == time_notes.length) {
                    notes_index = 0;
                }
            }


            setTimeout(timer, speeds[USER_SPEED]);
        }
        setTimeout(timer, speeds[USER_SPEED]);


        function tick(e) {
        var k = 0.04 * e.alpha;

        // Push nodes toward their designated focus.
        nodes.forEach(function(o, i) {
            var curr_act = o.act;
            var damper = 1;
            o.color = color(curr_act);
            o.y += (foci[curr_act].y - o.y) * k * damper;
            o.x += (foci[curr_act].x - o.x) * k * damper;
        });

        circle
            .each(collide(.5))
            .style("fill", function(d) { return d.color; })
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
        }


        // Resolve collisions between nodes.
        function collide(alpha) {
        var quadtree = d3.geom.quadtree(nodes);
        return function(d) {
            var r = d.radius + maxRadius + padding,
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
            quadtree.visit(function(quad, x1, y1, x2, y2) {
            if (quad.point && (quad.point !== d)) {
                var x = d.x - quad.point.x,
                    y = d.y - quad.point.y,
                    l = Math.sqrt(x * x + y * y),
                    r = d.radius + quad.point.radius + (d.act !== quad.point.act) * padding;
                if (l < r) {
                l = (l - r) / l * alpha;
                d.x -= x *= l;
                d.y -= y *= l;
                quad.point.x += x;
                quad.point.y += y;
                }
            }
            return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            });
        };
        }

        // Speed toggle
        d3.selectAll(".togglebutton")
        .on("click", function() {
            if (d3.select(this).attr("data-val") == "slow") {
                d3.select(".slow").classed("current", true);
                d3.select(".medium").classed("current", false);
                d3.select(".fast").classed("current", false);
            } else if (d3.select(this).attr("data-val") == "medium") {
                d3.select(".slow").classed("current", false);
                d3.select(".medium").classed("current", true);
                d3.select(".fast").classed("current", false);
            }
            else {
                d3.select(".slow").classed("current", false);
                d3.select(".medium").classed("current", false);
                d3.select(".fast").classed("current", true);
            }

            USER_SPEED = d3.select(this).attr("data-val");
        });
    }); // @end d3.tsv


    function color(activity) {

        var colorByActivity = {
            "0": "blue",
            "1": "red",
            "2": "yellow",
            "3": "brown",
            "4": "black",
            "5": "grey",
        }

        return colorByActivity[activity];

    }



    // Output readable percent based on count.
    function readablePercent(n) {

        var pct = 100 * n / 1000;
        if (pct < 1 && pct > 0) {
            pct = "<1%";
        } else {
            pct = Math.round(pct) + "%";
        }

        return pct;
    }


</script>

{% endblock %}
</body>
</html>
